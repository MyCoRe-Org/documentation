<document>
  <header>
    <title>Start- und Initialisierungsvorgang von MyCoRe im Detail</title>
    <version>2017-06-19</version>
    <release>2016.12</release>
    <authors>
      <person name="Paul Rochowski" email="[EMAIL PROTECTED]"/>
    </authors>
    <abstract>
      Damit die MIR Anwendung verwendet werden kann, wird diese in einem Servlet Webcontainer bereitgestellt. Doch wie
      funktioniert das genau? Wie bilden MyCoRe Komponenten, Anwendungskomponenten und eigene MIR Plugins eine Einheit?
      Was passiert im Hintergrund um dieses Konstrukt zu verbinden und zu starten? Diesem Thema soll sich der folgende
      Abschnitt widmen.
      Um zu verstehen wie so eine Initialisierung beginnt ist es zunächst notwendig die Situation aus dem Blickwinkel
      des Servlet Webcontainers vorzunehmen. Für diesen ist das MIR Webarchiv einfach nur eine Kollektion aus
      Komponenten der Servlet Spezifikation (Servlets, Filter, Listener) und anderen Resourcen. Damit diese Servlet
      Komponenten mit dem Webcontainer kommunizieren können wird eine Schnittstelle benötigt. Diese Schnittstelle wird
      mit dem ServletContext und seinem Set an Methoden zur Verfügung gestellt.
    </abstract>
  </header>
  
  <body>
    
    <section>
      <title>ServletContainerInitializer</title>
      <p>
        Seit Servlet Spezifikation 3.0 bietet die Servlet API das ServletContainerInitializer Interface an. Mittels
        eigener Implementierung kann die Startphase der Webanwendung individualisiert werden. Genau an dieser Stelle
        setzt das <code>mycore-base</code> an. Die Initialisierung von MyCoRe beginnt innerhalb der <em>onStart</em> Methode.
        Dieser Methode
        wird als Parameter der ServletContext mitgegeben. Auf diese Weise können programmatisch Servlets, Filter sowie
        Listener ergänzt werden. Genau dieser Mechanismus wird sich bei den vielen MyCoRe Kern Komponenenten/
        Anwendungskomponenten aber auch zusätzlichen Komponenten von MIR (siehe eigene JAR) zu nutzen gemacht.
      </p>
    </section>
    
    <section>
      <title>Vom ServletContainerInitializer zum MyCoRe Startup</title>
      <p>
        Die Klasse MCRServletContainerInitializer implementiert das ServletContainerInitializer Interface. Wie zuvor
        erwähnt wird diese Klasse ausgehend von der Servlet 3.0 Spezifikation als Initialisierungsklasse genutzt. MyCoRe
        erweitert diesen Mechanismus. Für MyCoRe ist diese Klasse nicht nur Servlet bezogen, sondern der Startpunkt für
        eine Reihe verschiedener
        Initialisierungsvorgänge mit unterschiedlichen Kontexten.
      </p>
      
      <div style="text-align:center;margin:10px 0;">
        <img src="resources/images/forDevelopers/initialization_fromMCRServletInitializer.png"
             alt="HelloWorldServlet in Aktion"
             style="margin:5px;padding:10px;border:1px solid gray;"
             width="650px"/>
        <br/>
        <span class="klein"><strong>Abbildung 1:</strong>Initialisierungsvorgänge mit unterschiedlichen Kontexten
        </span>
      </div>
    
    </section>
    
    <section>
      <title>Hinzufügen eines eigenen Startup Handlers</title>
      <p>
        MyCoRe bietet Entwicklern mit dem AutoExecutable Interface die Möglichkeit den Startup Vorgang zu
        beeinflussen.
        Um einen eigenen Startup Handler zu schreiben, muss die Klasse nur das AutoExecutable Interface implementieren
        und innerhalb der <code>mycore.properties</code> mittels <code>MCR.Startup.Class</code> bekanntgemacht werden.
        Im Folgenden werden die Methoden des AutoExecutable Interface erläutert:
      </p>
      <br/>
      <strong>int getPriority()</strong>
      <p>
        Mithilfe einer Priorität wird die Ausführungsreihenfolge der eigenen Klasse innerhalb des Startup Vorgangs
        definiert. MyCoRe selbst verfügt über eine Vielzahl von AutoExecutables, also Klassen die das AutoExecutable
        Interface implementieren. Diese Vielzahl wird mithilfe der Priorität nach Wichtigkeit sortiert. Als Beispiel
        soll hier die <code>MCRJPABootstrapper</code> Klasse genannt werden. Diese initialisiert die Schnittstelle
        zwischen Anwendung
        und Datenbank. Falls also ein AutoExecutable mittels JPA Datenbank Zugriff benötigt, kann dieser erst nach
        erfolgreichem durchlaufen des MCRJPABootstrappers stattfinden. Als vordefinierter Wert gilt eine Priorität von
        0.
      </p>
      <br/>
      <strong>String getName()</strong>
      <p>
        Der Rückgabewert gibt dem AutoExecutable einen sprechenden Namen und wird derzeit für Logging Zwecke verwendet.
      </p>
      <br/>
      <strong>startUp(ServletContext servletContext)</strong>
      <p>
        Über die startup Methode wird die benötigte Initialisierungslogik ausgeführt.
      </p>
    </section>
    
    
    <section>
      <title>MyCoRe Shutdown Handling</title>
      <p>
        Der MyCoRe Shutdown Mechanismus wird eingeleitet, sobald alle Servlets und Filter gemäß Servlet Lifecycle
        zerstört wurden. In der Regel ist dies der Fall, sobald der Webserver beendet werden soll.
        MyCoRe bietet dem Entwickler mit dem <code>Closeable</code> Interface eine Möglichkeit, seine eigenen Klassen
        innerhalb des Shutdown Vorgangs zu beenden.
        Die Implementierung des zentralen MyCoRe Shutdown Vorgangs befindet sich innerhalb der <code>
        MCRShutdownHandler
      </code> Klasse.
        Diese Klasse beinhaltet eine Menge registrierter Closeables (also Klassen die das Closeable Interface
        implementieren) und führt diese zum beschriebenen Zeitpunkt aus.
        Die Klasse ermöglicht es mit der addCloseable(Closeable) und removeCloseable(Closeable)Methode benötigte
        Closeables zu
        registrieren sowie zu entfernen. Ein Closeable muss sich also eigenverantwortlich beim <code>
        MCRShutdownHandler
      </code> melden.
      
      </p>
      
      <section>
        <title>Wann ist ein Closeable empfehlenswert / notwendig?</title>
        
        <p>
          MyCoRe benutzt an verschiedenen Stellen Closeables. Es macht immer dann Sinn eine Klasse mittels Closeable
          Interface zu implementieren, wenn Abhängigkeiten im Spiel sind.
          Beispiele hierfür sind JMX sowie JPA. Innerhalb der JMX Ebene betrifft dies MBeans. Sobald der Webserver
          beendet
          wird, macht es Sinn diese aus der MBean Server Registry zu entfernen um somit ggf. abhängigen MBeans, JMX
          Agenten sowie anderen Anwendungen mitzuteilen, dass bestimmte Ressourcen nicht mehr verfügbar sind.
        </p>
      </section>
      
      <section>
        <title>Methoden des Closeable Interface</title>
        <br/>
        <strong>void prepareClose()</strong>
        <p>
          Diese Methode wird als erste innerhalb des MyCoRe Shutdown Prozesses aufgerufen. Hier kann eine Vorbereitung
          für den eigentlichen <code>close()</code> Vorgang stattfinden. Eine Beispielimplementierung findet sich
          innerhalb der
          <code>MCRSolrIndexer</code>
          Klasse. Hier wird innerhalb der <code>prepareClose()</code> Methode der eigentliche Shutdown Prozess für die
          beteiligten Solr Services initialisiert. Dieser Stil ist vergleichbar mit einem asynchronen Aufruf. Innerhalb
          der <code>close()</code> Methode wird somit versucht auf die eigentliche Terminierungsantwort zu reagieren.
          Ein anderes Beispiel sind Objekte im Zusammenhang mit Datenbankverbindungen. Bevor Verbindungen zur Datenbank
          aufgrund des JPA Shutdowns (MCRJPAShutdownProcessor) nicht mehr möglich sind, könnten an dieser Stelle noch
          Datenbankzugriffe stattfinden.
        </p>
        <br/>
        <br/>
        <strong>void close()</strong>
        <p>
          Mithilfe der close() Methode wird einer Klasse die das Closeable Interface implementiert die Möglichkeit eines
          geordneten und sauberen Shutdown Prozesses im MyCoRe Umfeld ermöglicht. Diese Methode wird für das jeweilige
          Closeable nach der <code>prepareClose()</code> Methode aufgerufen. Vorrangig sollten hier wie im vorherigen
          Abschnitt bereits
          beschrieben Abhängigkeiten sauber geschlossen werden.
        </p>
        <br/>
        <br/>
        <strong>int getPriority()</strong>
        <p>
          Mittels Priorität ist es möglich die Closeables in einer Ausführungsreihenfolge zu sortieren. Ein Closeable
          mit einem höhreren Wert wird vor einem Closeable mit geringeren Wert geschlossen. Jedes Closeable besitzt eine
          definierte Standardpriorität.
        </p>
      </section>
    
    </section>
  
  
  </body>
</document>