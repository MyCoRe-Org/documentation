<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
  <header>
    <title>Die Arbeit mit der Beispielanwendung</title>
  </header>
<body>
  
   <section>
    <title>Benutzer der Beispielanwendung</title>
    <p>
    Die Beispielanwendung bringt zur Demonstration bereits eine Reihe von Benutzern und Gruppen mit. Einer Gruppe 
    können dabei mehrere Benutzer angehören. Die Vergabe von Rechten auf Objekte kann dann sowohl für einen einzelnen 
    Benutzer als auch für eine ganze Gruppe erfolgen. Im <a href="#ACL">Abschnitt "Zugriffsrechte auf Daten"</a> wird dieses Zugriffssystem (ACL-System) näher 
    erläutert.
    </p>    
    
    <table>
    <tr>
    <th>Gruppe</th>    
    <th>Beschreibung</th>
    </tr>
    <tr>
    <td>root</td>
    <td>Die Gruppe der Superuser</td>
    </tr>
    <tr>
    <td>admingroup</td>
    <td>Die Gruppe der Systemadministratoren</td>
    </tr>
    <tr>
    <td>readergroup1</td>
    <td>Eine Gruppe von Lesern der 1. Einrichtung (nur Leserechte für Objekte der Gruppe)</td>
    </tr>
    <tr>
    <td>readergroup2</td>
    <td>Eine Gruppe von Lesern der 2. Einrichtung (nur Leserechte für Objekte der Gruppe)</td>
    </tr>
    <tr>
    <td>authorgroup1</td>
    <td>Eine Gruppe von Autoren der 1. Einrichtung (Autorenrechte nur auf die eigenen Objekte)</td>
    </tr>
    <tr>
    <td>authorgroup2</td>
    <td>Eine Gruppe von Autoren der 2. Einrichtung (Autorenrechte nur auf die eigenen Objekte)</td>
    </tr>
    <tr>
    <td>editorgroup1</td>
    <td>Eine Gruppe von Editoren der 1. Einrichtung (Bearbeiter aller Objekte einer Einrichtung)</td>
    </tr>
    <tr>
    <td>editorgroup2</td>
    <td>Eine Gruppe von Editoren der 2. Einrichtung (Bearbeiter aller Objekte einer Einrichtung)</td>
    </tr>
    <tr>
    <td>gastgroup</td>
    <td>Die Gruppe der Gäste</td>
    </tr>    
    </table>
    <p class="klein"><strong>Tabelle 6.1:</strong> Beispielgruppen in DocPortal</p>
    
    <table>
    <tr>
    <th>Benutzer</th>
    <th>Gruppe</th>
    <th>Passwort</th>
    </tr>
    <tr>
    <td>root</td>
    <td>rootgroup</td>
    <td>alleswirdgut</td>
    </tr>
    <tr>
    <td>administrator</td>
    <td>admingroup</td>
    <td>alleswirdgut</td>
    </tr>
    <tr>
    <td>editor1A</td>
    <td>editorgroup1</td>
    <td>editor1A</td>
    </tr>
    <tr>
    <td>editor1B</td>
    <td>editorgroup1</td>
    <td>editor1B</td>
    </tr>
    <tr>
    <td>editor2A</td>
    <td>editorgroup2</td>
    <td>editor2A</td>
    </tr><tr>
    <td>editor2B</td>
    <td>editorgroup2</td>
    <td>editor2B</td>
    </tr>
    <tr>
    <td>author1A</td>
    <td>authorgroup1</td>
    <td>author1A</td>
    </tr>
    <tr>
    <td>author1B</td>
    <td>authorgroup1</td>
    <td>author1B</td>
    </tr>
    <tr>
    <td>author2A</td>
    <td>authorgroup2</td>
    <td>author2A</td>
    </tr>
    <tr>
    <td>author2B</td>
    <td>authorgroup2</td>
    <td>author2B</td>
    </tr>
    <tr>
    <td>reader1A</td>
    <td>readergroup1</td>
    <td>reader1A</td>
    </tr>
    <tr>
    <td>reader2A</td>
    <td>readergroup2</td>
    <td>reader2A</td>
    </tr>
    <tr>
    <td>gast</td>
    <td>gastgroup</td>
    <td>gast</td>
    </tr>
    </table>
    <p class="klein"><strong>Tabelle 6.2:</strong> Beispielbenutzer in DocPortal</p>
   
   </section>
  
  <anchor id="ACL" />
  <section>
   <title>Zugriffsrechte auf Daten</title>
   <p>
   Alle in MyCoRe gespeicherten Objekte besitzen einen Zugriffsschutz über Access Control Lists (ACL). 
   Dieser Schutzmechanismus ordnet jedem Objekt eine Reihe von Attributen zu, welche als Bedingung erfüllt sein müssen, 
   damit der Zugriff auf das Objekt gewährt wird. Der Vergleich der in den ACL's gespeicherten Voraussetzungen gegen 
   den aktuellen Zustand des Zugriffs erfolgt mittels der Sitzung (Session). In ihr werden alle Umgebungsinformationen 
   wie zugreifende IP, Benutzer, usw. gespeichert. Das für MyCoRe implementierte ACL-System kennt drei Attribute für die 
   Auswertung.
   </p>
   <ul>
   <li>Benutzer</li>
   <li>Gruppen</li>
   <li>Netzadressen in Form von IP's bzw. IP-Blöcken</li>
   </ul>
   <p>
   Bei der interaktiven Eingabe neuer Daten werden standardmäßig im Projekt festgelegte Zugriffsregeln vorgegeben. 
   Diese trennen sich in die Bereiche Lesen und Bearbeiten. Im Bereich des Bearbeitens wird wiederum in die Arbeit im 
   Workflow und im Server-System unterschieden. Hier können jeweils die Arbeitsgänge Editieren und Löschen getrennt 
   voneinander festgelegt werden. Für DocPortal sind folgende Berechtigungen (Permissions) definiert:
   </p>
   <ul>
   <li>read – gestattet den lesenden Zugriff</li>
   <li>writewf – gestattet das Schreiben bzw. Ändern, solange das Objekt im Simple Workflow (SWF) ist</li>
   <li>deletewf – gestattet das Löschen, solange das Objekt im Simple Workflow (SWF) ist</li>
   <li>writedb – gestattet das Schreiben bzw. Ändern, wenn das Objekt im Server ist</li>
   <li>deletedb - gestattet das Löschen, wenn das Objekt im Server ist</li>
   </ul>
   <p>
   Die Permissions werden in der Editor-Verarbeitung des Neuanlegens eines Datensatzes aus einem Standard-ACL-Datensatz 
   erzeugt. Hierzu kommt die Berechtigung des aktuellen Autors zu allen Bearbeitungsfunktionen. Die Leserechte sind für 
   alle Benutzer zugelassen. Diese Einstellung gilt konkret für die Docportal-Anwendung. Für eigene Projekte kann dies 
   ganz anders definiert werden. Die Permissions werden im Workflow-Prozess direkt im Datensatz gespeichert. Die 
   Notation der Zugriffsregeln im Datenabschnitt <em><strong>services</strong></em> ist als Datentyp 
   <em><strong>MCRMetaAccessRule</strong></em> im <a
   href="/documentation/version21/userguide/08_more_information.html#XML-Syntax+des+XML-Knotens+service">Abschnitt "Syntax
   des XML-Knotens service"</a> näher beschrieben. Beim Einstellen (Hochladen) der Objekte 
   in den Server werden die Regeln <strong>writewf</strong> und <strong>deletewf</strong> vollständig entfernt, da sie 
   nicht mehr benötigt werden. Alle anderen Zugriffsregeln werden im MyCoRe-ACL-System in die Datenbank eingetragen 
   und anschließend aus dem Originaldatensatz gelöscht. Damit ist das Objekt gesichert, ein Zugriff darauf benötigt 
   nun immer die Zustimmung der ACL-Komponente. Eine Änderung der Permissions kann nun nur noch bei einer 
   Schreibberechtigung erfolgen. Die interaktiven Komponenten von DocPortal bieten hier ein Aktionsfeld mit einem 
   Editor-Formular an. <strong>Nutzer der Gruppe admingroup sind immer für den Zugriff berechtigt, auch wenn dies nicht 
   explizit angegeben ist.</strong>
   </p>
   <p>
   Um den einzelnen digitalen Objekten ggf. eine höhere Sicherheit zu geben, können ergänzende Permissions in den 
   Derivate-XML-Daten angegeben werden. Bei einem Zugriff wird zuerst geprüft, ob Zugriffsrechte für den Metadatensatz 
   bestehen, anschließend wird geprüft ob es zusätzliche Einschränkungen aus dem Derivate gibt. Standardmäßig ist im 
   Derivate immer die Permission '<strong>true</strong>' gesetzt, was keinen weiteren Einschränkungen entspricht.
   </p>
   <p>
   Das ACL-System gestattet prinzipiell eine beliebige Sicherung mit anwendungsspezifischen Kriterien. Im 
   <a href="site:appdev_2_1">Programmer Guide</a> finden Sie detaillierte Informationen zur 
   Weiterentwicklung Ihrer eigenen Applikationen. 
   </p>
  </section>
  
  <section>
   <title>Die Verwendung der Kommandozeilenschnittstelle </title> 
   <p>
   Mit Hilfe der Kommandozeilenschnittstelle können Sie administrative Aufgaben für ihre MyCoRe-Anwendung auf 
   Kommandozeilenebene durchführen. Dies ermöglicht auch die Abarbeitung von Scripts zu Massenverwaltung der 
   eingestellten Daten. So können Sie etwa Objekte (Dokumente, Derivate, Personen, usw.) oder Klassifikationen in 
   das Repository einlesen, aktualisieren und löschen, Suchen durchführen und Objekte in Dateien exportieren. Diese 
   Funktionalitäten sind insbesondere bei einer Migration eines bestehenden Systems zur Sicherung der Daten sehr 
   sinnvoll.
   </p>
   <p>
   Die nachfolgenden Abschnitte sollen Ihnen eine Übersicht der möglichen Kommandos geben. Die einzelnen 
   Kommandogruppen werden dabei intern in den Kommandokern importiert und stehen dem Benutzer zur Verfügung. Die mit 
   dem MyCoRe-System ausgelieferten Kommandos können beliebig erweitert werden. Konsultieren Sie hierzu den 
   MyCoRe <a href="site:appdev_2_1">Programmer Guide</a>.
   </p>
   
   <section>
    <title>Basiskommandos des Kommandozeilensystems</title>
    <p>
    Das Kommandozeilensystem enthält eine kleine Zahl an Basiskommandos. Diese sollen im folgenden Abschnitt 
    beschrieben werden. Sie werden ergänzt durch weitere Kommandos für die einzelnen Bereiche der Arbeit mit MyCoRe. 
    Es besteht auch die Möglichkeit, eigene Anwendungskommandos als Java-Klassen zu entwickeln und zu integrieren. 
    Das Kommandozeilen-Tool ist <code>mycore.sh</code> bzw. <code>mycore.cmd</code> steht nach dem Erzeugen 
    mittels <code>ant create.scripts</code> im <code>bin</code>-Verzeichnis der Anwendung bereit. In den unten stehenden 
    Beschreibungen sind alle erforderlichen Parameter in der Form <code>{n}</code> notiert. <code>n</code> gibt dabei 
    die Nummer des Parameters an. Die Zählung beginnt bei 0.
    </p>
    
    <dl class="kasten">
    <dt><code>help</code></dt>
    <dd>Zeigt alle möglichen Kommandos, auch die von der Anwendung hinzugefügten.</dd>
    <dt><code>help {0}</code> </dt>
    <dd>Zeigt alle Kommandos, die mit {0} als Text beginnen</dd>
    <dt><code>process {0}</code></dt>
    <dd> Führt das im Parameter 0 angegebene System-Shell-Kommando aus.</dd>
    <dt><code>! {0}</code></dt>
    <dd>Führt das im Parameter 0 angegebene System-Shell-Kommando aus.</dd>   
    <dt><code>whoami</code></dt>
    <dd>Zeigt den aktuellen Benutzer an.</dd>
    <dt><code>login {0}</code></dt>
    <dd>Startet einen Benutzerwechsel-Dialog für den Benutzer {0}.</dd>
    <dt><code>change to user {0} with {1}</code></dt>
    <dd>Wechselt den Benutzer {0} mit dem Passwort {1}.</dd>
    <dt><code>show file {0}</code></dt>
    <dd>Zeigt den Inhalt der Datei {0} an. Eine absolute Pfadangabe für {0} ist erforderlich.</dd>
    <dt><code>show command statistics</code></dt>
    <dd>Zeigt eine Statistik der ausgeführten Kommandos und der Laufzeiten an.</dd>
    <dt><code>cancel on error</code></dt>
    <dd>Beendet die Ausführung folgender Kommandos im Fehlerfall.</dd>
    <dt><code>skip on error</code></dt>
    <dd>Übergeht Kommandos, welche bei der Ausführung fehl schlagen.</dd>
    <dt><code>exit</code></dt>
    <dd>Beendet das Kommandozeilensystem.</dd>
    <dt><code>quit</code></dt>
    <dd>Beendet das Kommandozeilensystem.</dd>
    </dl>
        
   </section>
   
   <section>
    <title>Kommandos zur Arbeit mit der Benutzerverwaltung </title>
    <p>    
    Eine Gruppe der verfügbaren Kommandos der Kommandozeilenschnittstelle ermöglicht die Verwaltung von Benutzern und 
    Gruppen. Diese Kommandos werden im folgenden vorgestellt. Oft werden bei den Kommandos XML-Dateien mit Definitionen 
    von Benutzern oder Gruppen erwartet. Die Syntax dieser XML-Beschreibungen finden Sie im 
    <a href="site:appdev_2_1">Programmer Guide</a>. Es werden derzeit nur die wichtigsten 
    Geschäftsprozesse der Benutzerverwaltung in den folgenden Kommandos abgebildet. 
    Der Schwerpunkt liegt auf einem Management-Interface für administrativen Zugriff. Die vollständige GUI der 
    Benutzerverwaltung (geplant für eine spätere Version) wird die Möglichkeit einer Bearbeitung aller Geschäftsprozesse 
    bieten.
    </p>
     
    <section>
    <title>Allgemeine Verwaltungskommandos</title>
    <anchor id="superuser" />

    <dl class="kasten">    
    <dt><code>init superuser</code></dt> 
    <dd>Dieses Kommando wird einmalig bei der Installation und Konfiguration des MyCoRe-Systems verwendet. Dabei werden 
    Daten über den zu verwendenden Administrations-Account und den Gast-Account aus den Konfigurationsdateien gelesen, 
    sowie das Benutzersystem initialisiert.</dd>    
    <dt><code>check user data consistency</code></dt> 
    <dd>Dieses Kommando dient zur Kontrolle der Konsistenz des Benutzersystems. Alle Verbindungen zwischen Benutzern 
    und Gruppen werden kontrolliert und Unregelmäßigkeiten, die eventuell durch den Import von Daten (
    siehe weiter unten) entstanden sind, werden ausgegeben.</dd>    
    <dt><code>set user management to ro mode</code></dt>
    <dd></dd>    
    <dt><code>set user management to rw mode</code></dt>
    <dd>Mit diesen Kommandos können die Daten der Benutzerverwaltung eingefroren werden. Dies sollte vor dem 
    Exportieren von Daten in XML-Dateien geschehen, damit sich nicht während des Exports Daten geändert oder Objekte 
    angelegt werden.</dd>
    </dl>
    </section>
     
    <section>
    <title>Kommandos zum Anlegen und Ändern von Gruppen und Benutzern aus XML-Dateien</title>
     
    <dl class="kasten">
    <dt><code>create user data from file {0}</code></dt>
    <dd></dd>
    <dt><code>create group data from file {0}</code></dt> 
    <dd>Diese Kommandos erwarten eine XML-Datei als Parameter. In der Datei müssen ein oder mehrere Definitionen von 
    Benutzern oder Gruppen existieren, die dann in das System übernommen werden. Ein Benutzerpasswort muss im Klartext 
    in der definierenden XML-Datei vorliegen (für die Syntax siehe den 
    <a href="site:appdev_2_1">Programmer Guide</a>). Ist die Passwortverschlüsselung eingeschaltet 
    (siehe <a href="#mpp">mycore.private.properties</a>), so wird das Passwort bei der Ablage in 
    der Datenbank verschlüsselt. Bei der Erzeugung der Objekte wird die Korrektheit der Eingaben bezüglich vorhandener 
    Regeln überprüft. So wird z.B. getestet, ob IDs doppelt vergeben wurden.</dd>
    <dt><code>import user system from files {0} {1}</code></dt>
    <dd>Dieses Kommando dient der Rekonstruktion des User Systems aus den abgesicherten Daten der Benutzer und Gruppen. 
    Da eine direkte Abhängigkeit zwischen beiden Teilen besteht werden alle Daten mittels eines gemeinsamen
    Kommandos verarbeitet. Dabei ist {0} die Guppen- und {1} die Benutzerdatei der Sicherung.</dd>
    <dt><code>update user data from file {0}</code></dt>
    <dd>Mit diesen Befehlen werden bereits vorhandene Benutzer aktualisiert. Dabei ist zu bedenken, dass „update“ im 
    Sinne von „festsetzen auf neue Werte“ zu verstehen ist, die Objekte also nach dem update genau die Definitionen 
    haben, die in den XML-Dateien festgelegt werden. Einige der Attribute können allerdings nicht verändert werden, 
    z.B. die Erzeuger-Accounts oder das Datum der Erzeugung. Sollen diese Daten unbedingt verändert werden, dann 
    müssen die Objekte vorher gelöscht und neu angelegt werden.</dd>
    <dt><code>export all users to file {0}</code></dt>
    <dd></dd>
    <dt><code>export all groups to file {0}</code></dt>
    <dd></dd>
    <dt><code>export user {0} to file {1}</code></dt>
    <dd></dd>
    <dt><code>export group {0} to file {1}</code></dt>
    <dd>Mit diesen Kommandos werden alle oder einzelne Objekte der Benutzerverwaltung in XML-Dateien gespeichert. 
    Passwörter von Benutzern werden bei eingeschalteter Verschlüsselung verschlüsselt abgelegt. Die so entstandenen 
    Dateien können beispielsweise mit den import-Kommandos wieder geladen werden.</dd>
    <dt><code>encrypt passwords in user xml file {0} to file {1}</code></dt>
    <dd>Passwortverschlüsselung kann durch einen Konfigurationsparameter in der Datei mycore.properties.user aktiviert 
    oder deaktiviert werden. Dieses Kommando wird benötigt, wenn man ein bestehendes System mit nicht eingeschalteter 
    Verschlüsselung auf ein System mit Verschlüsselung migrieren will. Dabei verfährt man folgendermaßen: Zunächst 
    werden alle Benutzer des alten Systems mit dem Kommando (siehe oben) export all users to file in eine XML-Datei 
    exportiert. Daraufhin wendet man encrypt passwords in user xml file {0} to file {1} auf diese Datei an und erhält 
    damit verschlüsselte Passwörter in den XML-Dateien. Mit dem Kommando (siehe oben) update user data from file 
    können diese Daten in das System reintegriert werden. Danach muss die Kommandozeilenschnittstelle geschlossen und 
    die Verschlüsselung in mycore.properties.user eingeschaltet werden.</dd>
    </dl>
    </section>
     
    <section>
    <title>Kommandos zum direkten Arbeiten mit Objekten der Benutzerverwaltung</title>
     
    <dl class="kasten">
    <dt><code>delete user {0}</code></dt>
    <dd></dd>
    <dt><code>delete group {0}</code></dt>
    <dd>Durch Angabe des Benutzer- oder Gruppennamens werden die Objekte mit diesen Kommandos aus dem System entfernt 
    (und abhängige Objekte aktualisiert).</dd>
    <dt><code>list all users</code></dt>
    <dd></dd>
    <dt><code>list user {0}</code></dt>
    <dd></dd>
    <dt><code>list all groups</code></dt>
    <dd></dd>
    <dt><code>list group {0}</code></dt>
    <dd>Die Kommandos dienen dem Auflisten der Objekte der Benutzerverwaltung und sind selbsterklärend.</dd>
    <dt><code>set password for user {0} to {1}</code></dt>
    <dd>Mit Hilfe dieses Befehls kann das Passwort eines Benutzers direkt über die Kommandozeile gesetzt werden. 
    Voraussetzung ist, dass die notwendigen Privilegien vorliegen.</dd>
    <dt><code>enable user {0}</code></dt>
    <dd></dd>
    <dt><code>disable user {0}</code></dt>
    <dd>Mit Hilfe dieser Kommandos können einzelne Benutzer temporär deaktiviert und wieder aktiviert werden. 
    Ist ein Benutzer disabled, so kann er oder sie sich nicht mehr am System anmelden.</dd>
    <dt><code>add user {0} as member to group {1}</code></dt>
    <dd></dd>
    <dt><code>remove user {0} as member from group {1}</code></dt>
    <dd>Mit diesen Kommandos kann direkt auf die Mitgliederlisten von Gruppen zugegriffen werden, indem Mitglieder 
    (sowohl Gruppen als auch Benutzer) hinzugefügt oder gelöscht werden können.</dd>
    </dl>
    </section>
     
    <section>
    <title>Das Sichern und Restaurieren der Benutzerverwaltungsdaten</title>
     
    <p>
    Während der Initialisierung eines MyCoRe-Systems werden ein Administrations-Account und ein Gastzugang eingerichtet 
    zusammen mit den zugehörigen primären Gruppen (siehe <a href="#superuser">Kommando <code>init superuser</code></a>). 
    Dadurch ist das Sichern und Reimportieren der gesamten Daten der Benutzerverwaltung mit etwas mehr Handarbeit 
    verbunden, weil der Administrations-Account und Gastzugang zwar mit gesichert werden, aber vor einer Restauration der 
    Daten z.B. nach einem Crash der SQL-Datenbank neu initialisiert werden müssen. Das bedeutet, dass sie bereits vorhanden sind und 
    ein <code>import user data from file</code> deswegen nicht geht. Andererseits können sich die Daten dieser beiden 
    Benutzer natürlich auch verändert haben, so dass die alten Daten wieder hergestellt werden müssen. Der folgende 
    Ablauf führt zum Ziel. Dabei stehen <code>&lt;superuser&gt;</code> und <code>&lt;superuser-group&gt;</code> bzw. 
    <code>&lt;guest&gt;</code> und <code>&lt;guest-group&gt;</code> für die in <code>mycore.private.properties</code> 
    eingetragenen Parameter für den Administrations- und Gastzugang. In der MyCoRe-Kommandozeile werden die folgenden 
    Befehle durchgeführt:
    </p>
     
    <source class="code">
<![CDATA[MyCoRe:> export user <superuser> to file <superuser.xml>
MyCoRe:> export user <guest> to file <guest.xml>
MyCoRe:> export group <superuser-group> to file 
         <superuser-group.xml>
MyCoRe:> export group <guest-group> to file <guest-group.xml>
MyCoRe:> export all users to file <all-users.xml>
MyCoRe:> export all groups to file <all-groups.xml>]]></source>
      
    <p>
    Die Benutzer <code>&lt;superuser&gt;</code> und <code>&lt;guest&gt;</code> sowie die zugehörigen Gruppen müssen 
    aus den Dateien <code>&lt;all-users.xml&gt;</code> bzw. <code>&lt;all-groups.xml&gt;</code> manuell entfernt 
    werden. Dann können alle Daten in einer neu erstellten SQL-Datenbank folgendermaßen importiert werden:
    </p>
     
    <source class="code">
<![CDATA[MyCoRe:> init superuser
MyCoRe:> import user data from file <all-users.xml>
MyCoRe:> import group data from file <all-groups.xml>
MyCoRe:> update user data from file <superuser.xml>
MyCoRe:> update user data from file <guest.xml>
MyCoRe:> update group data from file <superuser-group.xml>
MyCoRe:> update group data from file <guest-group.xml>
MyCoRe:> check user data consistency]]></source>
   </section>
   </section>
   
   <section>
    <title>Kommandos zur Administration des ACL-Systems</title>
     
    <dl class="kasten">
    <dt><code>load permissions data from file {0}</code></dt>
    <dd>Das Kommando lädt statische Permissions aus der Datei {0}.</dd>
    <dt><code>update permission {0} for id {1} with rulefile {2}</code></dt>
    <dd></dd>
    <dt><code>update permission {0} for id {1} with rulefile {2} described by {3}</code></dt>
    <dd></dd>
    <dt><code>update permission {0} for selected with rulefile {2}</code></dt>
    <dd></dd>
    <dt><code>update permission {0} for selected with rulefile {2} described by {3}</code></dt>
    <dd></dd>
    <dt><code>list all permissions</code></dt>
    <dd>Das Kommando listet alle statischen Permissions.</dd>
    <dt><code>delete permissions {0}</code></dt>
    <dd>Das Kommando löscht die in {0} angegebene Permission.</dd>
    <dt><code>delete all permissions</code></dt>
    <dd>Das Kommando löscht alle statischen Permissions.</dd>
    <dt><code>export all permissions to file {0}</code></dt>
    <dd>Das Kommando sichert alle statischen Permissions in die unter {0} angegebene Datei.</dd>
    </dl>
   </section>
   
   <section>
    <title>Kommandos zum Verwalten von Klassifikationen</title>
     
    <dl class="kasten">
    <dt><code>load classification from file {0}</code></dt>
    <dd>Es wird eine Klassifikation in Form einer XML-Definition aus der Datei {0} gelesen und in das System geladen.</dd>
    <dt><code>load all classifications from directory {0}</code></dt>
    <dd>Es werden alle XML-Definitionen von Klassifikationen aus einem Verzeichnis {0} gelesen und in das System geladen.</dd>
    <dt><code>update classification from file {0}</code></dt>
    <dd>Es wird eine Klassifikation in Form einer XML-Definition aus der Datei {0} gelesen. Diese überschreibt die im System bereits 
    geladene Klassifikation. Achtung, lassen Sie keine Kategorien einer bestehenden Klassifikation weg, da sonst Ihr 
    System ggf. in einen inkonsistenten Zustand kommen kann! Referenzierte Kategoien werden nicht beseitigt.</dd>
    <dt><code>update all classifications from directory {0}</code></dt>
    <dd>es werden alle XML-Definitionen von Klassifikationen aus einem Verzeichnis {0} gelesen. Diese überschreiben die im 
    System bereits geladenen Klassifikationen. Achtung, lassen Sie keine Kategorien einer bestehenden Klassifikation 
    weg, da sonst Ihr System ggf. in einen inkonsistenten Zustand kommen kann! Referenzierte Kategoien werden nicht beseitigt.</dd>
    <dt><code>delete classification {0}</code></dt>
    <dd>Es wird eine Klassifikation mit der im Parameter <code>{0}</code> angegebenen <code>MCRObjectID</code> 
    gelöscht. Sollten noch Referenzen existieren, wird das Löschen abgebrochen.</dd>
    <dt><code>export classification {0} to {1} with {2}</code></dt>
    <dd>Es wird eine Klassifikation mit der im Parameter <code>{0}</code> angegebenen <code>MCRObjectID</code> 
    in eine Datei mit dem im Parameter <code>{1}</code> angegeben Namen gespeichert. Es wird zur Transformation 
    der zu speichernden Daten das Stylesheet <code>{2}-classification.xsl</code> unter 
    <code>$DOCPORTAL_HOME/build/xsl</code> verwendet.</dd>
    <dt><code>export all classifications to directory {0} with {1}</code></dt>
    <dd>Es werden alle im System befindlichen Klassifikationen in Dateien des Verzeichnisses mit dem im Parameter 
    <code>{0}</code> angegeben Namen gespeichert. Es wird zur Transformation der zu speichernden Daten das Stylesheet <code>{1}-classification.xsl</code> unter 
    <code>$DOCPORTAL_HOME/build/xsl</code> verwendet.</dd>
    <dt><code>count classification children of {0}</code></dt>
    <dd>Es werden die Referenzen zu den Kategorien der im Parameter <code>{0}</code> angegebenen Klassifikation mit der <code>MCRObjectID</code> gezählt.</dd>
    <dt><code>list all classifications</code></dt>
    <dd>Das Kommando listet alle in der Datenbasis gespeicherten Klassifikationen aus.</dd>
    <dt><code>list classification {0}</code></dt>
    <dd>Das Kommando listet die unter der <code>MCRObjectID</code> in der Datenbasis gespeicherte Klassifikation mit alle Kategorien aus.</dd>
    </dl>
   </section>
   
   <section>
    <title>Kommandos zur Verwaltung der Objekte</title>
    <dl>
    <dt><code>load object from file {0}</code></dt>
    <dd></dd>
    <dt><code>load all objects from directory {0}</code></dt>
    <dd></dd>
    <dt><code>load derivate from file {0}</code></dt>
    <dd></dd>
    <dt><code>load all derivates from directory {0}</code></dt>
    <dd>die Kommandos laden die Metadaten-Objekte oder die Derivate inklusive ihrer Bilder und Dokumente von einer 
    Quelldatei oder einem Quellverzeichnis in das System.</dd>
    <dt><code>update object from file {0}</code></dt>
    <dd></dd>
    <dt><code>update all objects from directory {0}</code></dt>
    <dd></dd>
    <dt><code>update derivate from file {0}</code></dt>
    <dd></dd>
    <dt><code>update all derivates from directory {0}</code></dt>
    <dd>die Kommandos laden die Metadaten-Objekte oder die Derivate inklusive ihrer Bilder und Dokumente von einer 
    Quelldatei oder einem Quellverzeichnis in das System. Dabei werden die bestehenden Daten bis auf 
    Strukturinformationen überschrieben. Strukturinformationen sind ggf. Daten über Vater-Kind- oder 
    Objekt-Derivate-Beziehungen.</dd>
    <dt><code>export object {0} to directory {1} with {2}</code></dt>
    <dd></dd>
    <dt><code>export object from {0} to {1} to directory {2} with {3}</code></dt>
    <dd></dd>
    <dt><code>export all objects of type {0} to directory {1} with {2}</code></dt>
    <dd></dd>
    <dt><code>export derivate of {0} to directory {1}</code></dt>
    <dd></dd>
    <dt><code>export derivate from {0} to {1} to directory {2}</code></dt>
    <dd></dd>
    <dt><code>export all derivates to directory {0} with {1}</code></dt>
    <dd>die Kommandos speichern ein oder mehrere Metadaten-Objekte oder Derivate in ein Verzeichnis ab. Für die 
    Parameter <code>{0}</code> und <code>{1}</code> bzw. <code>{0}</code> sind <code>MCRObjectIDs</code> anzugeben. 
    Es werden zur Transformation der zu speichernden Daten die Stylesheets <code>{3}-object.xsl</code> und 
    <code>{3}-derivate.xsl</code> unter <code>$DOCPORTAL_HOME/stylesheets</code> verwendet. 
    Standard ist <code>save-object.xsl </code> bzw. <code>save-derivate.xsl.</code></dd>
    <dt><code>delete object {0}</code></dt>
    <dd></dd>
    <dt><code>delete object from {0} to {1}</code></dt>
    <dd></dd>
    <dt><code>delete derivate {0}</code></dt>
    <dd></dd>
    <dt><code>delete derivate from {0} to {1}</code></dt>
    <dd>die Kommandos löschen einzelnen Metadaten-Objekte oder Derivate oder ganze Gruppen von selbigen. 
    Alle Parameter müssen dabei <code>MCRObjectID</code>'s sein.</dd>
    <dt><code>delete all objects of type {0}</code></dt>
    <dd>das Kommando löscht alle eingestellten Objekte eines bestimmten Datentypes.</dd>
    <dt><code>delete all derivates</code></dt>
    <dd>das Kommando löscht alle eingestellten Derivate.</dd>
    <dt><code>show loadable derivate of {0} to directory {1}</code></dt>
    <dd>das Kommando speichert den Content des Derivates vom Objekt mit der <code>MCRObjectID {0}</code> in das 
    Verzeichnis <code>{1}</code>.</dd>
    </dl>
   </section>
   
   <section id="cmd_iview">
    <title>Kommandos zur Arbeit mit dem ImageViewer</title>
    <dl>
    <dt><code>tile images of all derivates</code></dt>
    <dd>das Kommando erzeugt Kacheln für alle Bilddateien (deren Formate unterstützt werden).</dd>
    <dt><code>tile images of derivate {0}</code></dt>
    <dd>das Kommando erzeugt Kacheln für alle Bilddateien im angegebenen Derivat <code>{0}</code>.</dd>
    <dt><code>tile image {0} {1}</code></dt>
    <dd>das Kommando generiert die Kacheln für die angegebenen Datei aus dem Derivate <code>{0}</code>
      entsprechend des absoluten Pfades {1}.</dd>
    <dt><code>check tiles of image {0} {1}</code></dt>
    <dd>das Kommando prüft alle Kacheln der angegebenen Datei aus dem Derivate <code>{0}</code>
      entsprechend des absoluten Pfades {1} und generiert bei Bedarf neue Kacheln.</dd>
    <dt><code>delete tiles of image {0} {1}</code></dt>
    <dd>das Kommando löscht alle Kacheln der angegebenen Datei aus dem Derivate <code>{0}</code>
      entsprechend des absoluten Pfades {1}.</dd>
    </dl>
   </section>
   
   <section>
    <title>Kommandos zur Konsistenzprüfung im IFS (Dateien in Derivaten)</title>
    <dl>
    <dt><code>generate md5sum files in directory {0}</code></dt>
    <dd>
      Mit diesem Befehl kann man Dateien erzeugen, die zu dem "md5sum"-Programm kompatibel sind. 
      Pro Content-Store-ID, wird eine Datei im angegebenen Verzeichnis angelegt, in der alle Dateien 
      des Content-Stores alphabetisch sortiert mit MD5 Summe hinterlegt sind.
      Diese MD5-Datei kann man mit "md5sum -c Datei.md5" zum Überprüfen aller Dateien benutzen, 
      um so Änderungen oder fehlende Dateien feststellen zu können.
      Mit einer sortierten Liste (z.B. per find) der Dateien im Content-Store, kann man mit einem Script 
      zusätzlich noch leicht herausfinden, welche Dateien in der Datenbank nicht vermerkt sind, 
      aber noch Platz wegnehmen.
    </dd>
    <dt><code>generate missing file report in directory {0}</code></dt>
    <dd>
      Erzeugt einen Bericht als XML-Datei, in der alle verlorenen Dateien aufgelistet sind. 
    </dd>
    <dt><code>generate md5 file report in directory {0}</code></dt>
    <dd>
      Erzeugt einen Bericht als XML-Datei, in der alle veränderten Dateien mit fehlerhafter MD5 Prüfsumme aufgelistet sind. 
    </dd>
    </dl>
   </section>

   <section>
    <title>Anfragen an das System per Kommandozeile</title>
    <dl>
    <dt><code>run query from file {0}</code></dt>
    <dd>das Kommando startet eine Anfrage mit einer Query, welche im File <code>{0}</code> steht.</dd>
    <dt><code>run local query {0}</code></dt>
    <dd>das Kommando startet eine Anfrage gegen das lokale System mit einer Query, welche im String <code>{0}</code> 
    steht.</dd>
    <dt><code>run distributed query {0}</code></dt>
    <dd>das Kommando startet eine Anfrage gegen alle bekannten Systeme mit einer Query, welche im String <code>{0}</code> 
    steht.</dd>
    </dl>
   </section>
   
   <section>
    <title>Sonstige Kommandos</title>
    <dl>
    <dt><code>repair metadata search of type {0}</code></dt>
    <dd></dd>
    <dt><code>repair metadata search of ID {0}</code></dt>
    <dd>die Kommandos lesen die XML-SQL-Tabellen und reparieren zerstörte Metadaten-Suchindizes. Das Kommando kann 
    auch beim Wechsel eines <code>SearchStore</code> angewendet werden.</dd>
    <dt><code>repair derivate search of type derivate</code></dt>
    <dd></dd>
    <dt><code>repair derivate search of ID {0}</code></dt>
    <dd>die Kommandos lesen die gespeicherten Datenobjekte und reparieren zerstörte Volltext-Suchindizes. Das Kommando 
    kann auch beim Wechsel eines <code>SearchStore</code> angewendet werden.</dd>
    <dt><code>get last ID for base {0}</code></dt>
    <dd></dd>
    <dt><code>get next ID for base {0}</code></dt>
    <dd></dd>
    <dt><code>show last object ID for base {0}</code></dt>
    <dd></dd>
    <dt><code>show next object ID for base {0}</code></dt>
    <dd>die Kommandos liefern die nächste freie oder die letzte <code>MCRObjectID</code> für eine vorgegeben 
    <code>MCRObjectID</code>-Basis zurück. Die Basis besteht aus Projekt- und Type-String in der Form 
    <code>project_type</code>. (Siehe Abschnitt zur <a href="#MCRO">MCRObjectID</a>)</dd>
    <dt><code>check file {0}</code></dt>
    <dd>prüft eine im Parameter <code>{0}</code> angegebene Datei mittels XML-Parser.</dd>
    <dt><code>init hibernate</code></dt>
    <dd>das Kommando initialisiert den Hibernate-SQL-Store. Das Kommando ist nur einmal erforderlich!</dd>
    </dl>
   </section>
   
  </section>
  
  <section>
   <title>Das SimpleWorkflow-System zur interaktiven Autorenarbeit</title>
   <p>
   Das SimpleWorkflow-System wurde entwickelt, um mit einem einfachen Werkzeug die interaktive Autoren- und 
   Editorenarbeit zu ermöglichen und damit eine sinnvolle Arbeit mit einer MyCoRe-Applikation zu ermöglichen. Es ist 
   jedoch so konzipiert, dass es auch über eine Servlet-Schnittstelle in größere Workflow-Engines eingebunden werden 
   kann. Einen Workflow im eigentlichen Sinne gibt es nur sehr eingeschränkt und in einfachem Ablauf. Weiterführende 
   organisatorische Maßnahmen waren auch nicht Ziel dieser Entwicklung.
   </p>
   <p>
   Die Komponente wurde in ein Modul verlagert und ist somit durch andere Komponenten ersetzbar. 
   Eine genaue Beschreibung der Details zur Integration finden Sie im 
   <a href="site:appdev_2_1">Programmer Guide</a>. Die wichtigsten Merkmale dieses Moduls sind:
   </p>
   <ul>
   <li>Mit dem System kann ein einfacher Eingabe- und Bearbeitungs-Dialog realisiert werden.</li>
   <li>Eingabe und Bearbeitung werden durch eine Rechtekontrolle mittels des ACL-System realisiert. 
       Nur berechtigte Benutzer dürfen die Daten verändern.</li>
   <li>Die Zwischenspeicherung aller eingehenden Daten erfolgt zuerst auf einem Plattenbereich, so dass bei 
       Fehlern ggf. auch der Administrator direkt eingreifen kann. Daten die erfolgreich in den Server geladen 
       wurden, werden aus diesem Plattenbereich gelöscht.</li>
   <li>Das System benutzt die MyCoRe-interne Editor-Komponente.</li>
   <li>Das System basiert auf einer Reihe von Servlets, XML-Seiten und Stylesheets, sowie der Einbindung in die 
       Editor-Formulare.</li>
   <li>Alle Funktionen werden über ein einheitliches Servlet initiiert (<code>MCRStartEditorServlet</code>). 
       Die möglichen Aufrufe sind weiter unten notiert.</li>
   </ul>
   
   <img src="images/userguide_simpleworkflow_1.jpg" alt="Funktionsschema SimpleWorkflow" />
    <p class="klein"><strong>Abbildung 6.1:</strong> Funktionsschema des SimpleWorkflow</p>  
   
   <section>
    <title>Das MCRStartEditorServlet</title>
    <p>
    Dieses Servlet ist der Einstiegspunkt für die Nutzung des SimpleWorkflow-Systems. Von ihm aus werden alle 
    Verarbeitungsprozesse angestoßen. Das Servlet seinerseits startet dann wieder Web-Dialoge oder führt selbstständig 
    Aktionen aus. Dabei sind die folgenden Startparameter von Interesse:
    </p>
    
    <table>
    <tr>
    <th>Parameter</th>
    <th>Bedeutung</th>
    </tr>
    <tr>
    <td>todo</td>
    <td>Zeigt an, welche Aktion auszuführen ist.</td>
    </tr>
    <tr>
    <td>type</td>
    <td>Gibt den Datenmodell-Typ des Metadaten-Objektes an.</td>
    </tr>
    <tr>
    <td>step</td>
    <td>Gibt den Verarbeitungsschritt an (z. B. author, editor, commit).</td>
    </tr>
    <tr>
    <td>layout</td>
    <td>Gestattet eine verfeinerte Angabe des Verarbeitungsschrittes (ist optional).</td>
    </tr>
    <tr>
    <td>tf_mcrid</td>
    <td>Enthält eine MCRObjektID, welche neu hinzugekommen und/oder dem System noch nicht bekannt ist. 
    Die Gültigkeit wird geprüft.</td>
    </tr>
    <tr>
    <td>se_mcrid</td>
    <td>Enthält eine MCRObjectID, welche aus einem Datensatz oder ähnlichen Quellen extrahiert wurde und gültig 
    sein sollte.</td>
    </tr>
    <tr>
    <td>re_mcrid</td>
    <td>Enthält eine weitere MCRObjectID, welche aus einem Datensatz oder ähnlichen Quellen extrahiert wurde und 
    gültig sein sollte (z.B. zugehöriger Metdatensatz).</td>
    </tr>
    <tr>
    <td>extparm</td>
    <td>Erweiterungsparameter, wie in einigen wenigen Fällen benutzt.</td>
    </tr>
    </table>
    <p class="klein"><strong>Tabelle 6.3:</strong> Parameter des MCRStartEditorServlets</p>
    
    <p>
    Die nächsten Tabellen sollen eine Übersicht der möglichen Aktionen geben. Jede Aktion ist dabei an eine 
    entsprechende Berechtigung gebunden, welche der aktuelle Benutzer gerade haben muss. Hat er sie nicht, so wird 
    seine Aktion abgewiesen und nicht ausgeführt. Dabei wird noch nach dem Datenmodell-type unterschieden, d.h. 
    ein Benutzer muss für genau diesen type auch die Berechtigung haben. Die Aktionen unterscheiden sich in dem 
    Ziel-Store, todo=w... steht für den Plattenbereich; todo=s... arbeitet mit den bereits eingestellten Server-Daten. 
    Der Parameter layout ist optional und dient der Verfeinerung der möglichen Arbeitsschritte. Während alle Aktionen, 
    die mit einem w beginnen auf dem Plattenbereich (workflow) arbeiten, veranlassen alle Aktionen mit s einen Zugriff 
    und Änderungen im Server-System.
    </p>
    
    <table>
    <tr>
    <th>Aktion</th>
    <th>todo</th>
    <th>ID</th>
    <th>Permission</th>
    <th>ruft</th>
    </tr>
    <tr>
    <td>Anlegen neuer Metadaten </td>
    <td>wnewobj</td>
    <td>tf_mcrid</td>
    <td>create-type</td>
    <td>editor_form_author-type[-layout].xml</td>
    </tr>
    <tr>
    <td>Anlegen eines Neuen Derivates </td>
    <td>wnewder</td><td>se_mcrid</td>
    <td>create-type</td>
    <td>MCRStartEditorServlet?todo=waddfile</td>
    </tr>
    <tr>
    <td>Hinzufügen neuer Dateien aus dem Upload</td>
    <td>waddfile</td>
    <td>se_mcrid re_mcrid</td>
    <td>writewf</td>
    <td>fileupload_new.xml</td>
    </tr>
    <tr>
    <td>Bearbeiten von Metadaten </td>
    <td>weditobj</td><td>se_mcrid</td>
    <td>writewf</td>
    <td>editor_form_type_[layout_]editor.xml</td>
    </tr>
    <tr>
    <td>Bearbeiten des Label eines Derivate-Metadaten-Satzes</td>
    <td>weditder</td><td>se_mcrid re_mcrid</td>
    <td>writewf</td>
    <td>editor_form_derivate_editor.xml</td>
    </tr>
    <tr>
    <td>Löschen aller Daten eines Objektes </td>
    <td>wdelobj</td>
    <td>se_mcrid</td>
    <td>deletewf</td>
    <td>editor_type_editor.xml</td>
    </tr>
    <tr>
    <td>Löschen eines Derivates </td>
    <td>wdelder</td>
    <td>se_mcrid</td>
    <td>deletewf</td>
    <td>editor_type_editor.xml</td>
    </tr>
    <tr>
    <td>Löschen einer Datei aus einem Derivate</td>
    <td>wdelfile</td>
    <td>se_mcrid</td>
    <td>writewf</td>
    <td>editor_type_editor.xml</td>
    </tr>
    <tr>
    <td>Setzen der Hauptdatei in einem Derivate</td>
    <td>wsetfile</td><td>se_mcrid</td><td>writewf</td>
    <td>editor_type_editor.xml</td>
    </tr>
    <tr>
    <td>Hochladen eines Datensatzes vom Plattenbereich zum Server</td>
    <td>wcommit</td>
    <td>se_mcrid</td>
    <td>writedb</td>
    <td>MCRQueryServlet mit der ID mit mode=ObjectMetadata</td>
    </tr>
    </table>
    <p class="klein"><strong>Tabelle 6.4:</strong> Mögliche Aktionen mit dem MCRStartEditorServlet auf dem Plattenbereich</p>
    
    <table>
    <tr>
    <th>Aktion</th>
    <th>todo</th>
    <th>ID</th>
    <th>Permission</th>
    <th>ruft</th>
    </tr>
    <tr>
    <td>Bearbeiten der Metadaten</td>
    <td>seditobj</td>
    <td>se_mcrid</td>
    <td>writedb</td>
    <td>MCRQueryServlet mit der ID mit mode=ObjectMetadata</td>
    </tr>
    <tr>
    <td>Bearbeiten des Label der Derivate-Metadaten </td>
    <td>seditder</td>
    <td>se_mcrid re_mcrid</td>
    <td>writedb</td>
    <td>editor_form_commit_derivate.xml</td>
    </tr>
    <tr>
    <td>Löschen eines Datenobjekts</td>
    <td>sdelobj</td>
    <td>se_mcrid</td>
    <td>deletedb</td>
    <td>editor_deleted.xml</td>
    </tr>
    <tr>
    <td>Löschen eines Derivates von einem Datenobjekt</td>
    <td>sdelder</td>
    <td>se_mcrid re_mcrid</td>
    <td>deletedb</td>
    <td>MCRQueryServlet mit der ID mit mode=ObjectMetadata</td>
    </tr>
    <tr>
    <td>Hinzufügen eines neuen Derivates zu einem Datenobjekt des Servers; Zwischenablage der Daten auf dem 
    Plattenbereich</td>
    <td>snewder</td>
    <td>re_mcrid</td>
    <td>writedb</td>
    <td>MCRStartEditorServlet?todo=saddfile</td>
    </tr>
    <tr>
    <td>Hinzufügen von Daten zu einem Derivate aus dem Server; Zwischenablage der Daten auf dem Plattenbereich</td>
    <td>snewfile</td>
    <td>se_mcrid re_mcrid</td>
    <td>writedb</td>
    <td>MCRStartEditorServlet?todo=saddfile</td>
    </tr>
    <tr>
    <td>Upload von Datenobjekten in die Zwischenablage</td>
    <td>saddfile</td>
    <td>se_mcrid re_mcrid</td>
    <td>writedb</td>
    <td>MCRStartEditorServlet?todo=scommitder</td>
    </tr>
    <tr>
    <td>Setzen Des Label in einem Derivate</td>
    <td>ssetlabel</td>
    <td>se_mcrid re_mcrid</td>
    <td>writedb</td>
    <td>MCRQueryServlet mit der ID mit mode=ObjectMetadata</td>
    </tr>
    <tr>
    <td>Setzen der Main File Markierung im Derivate</td>
    <td>ssetfile</td>
    <td>se_mcrid re_mcrid</td>
    <td>writedb</td>
    <td>MCRFileNodeServlet mit der ID des Derivates</td>
    </tr>
    <tr>
    <td>löschen einer Datei aus einem Derivate</td>
    <td>sdelfile</td>
    <td>se_mcrid re_mcrid</td>
    <td>writedb</td>
    <td>MCRFileNodeServlet mit der ID des Derivates</td>
    </tr>
    </table>
    <p class="klein"><strong>Tabelle 6.5:</strong> Mögliche Aktionen mit dem MCRStartEditorServlet im Server</p>
    
   </section>
   
   <section>
    <title>Abläufe für neue Datenobjekte</title>
    <p>
    Die Abläufe für die Eingabe neuer Datensätze sind praktisch für alle Datenmodelle gleich. Lediglich die Anbindung 
    der Derivate an die Metadaten-Objekte ist nicht immer gegeben. Das hängt allein an der Gestaltung des jeweiligen 
    Datenmodell-Konzeptes für ein Projekt (z.B. haben Personendaten im DocPortal-Projekt keine eigenen Derivate). 
    Wird beim SimpleWorkflow ein neues Objekt eingestellt, so befinden sich alle relevanten Daten vorerst auf einem 
    Plattenbereich, der über die Konfiguration festgelegt wird. Erst wenn das Commit (Laden) zum Server-System ausgeführt 
    wurde, werden die Daten von diesem Zwischenspeicher wieder gelöscht. Jeder Datenmodell-type hat dabei in der Regel 
    ein eigenes Verzeichnis innerhalb des Workflow-Plattenbereiches.
    </p>    
   </section>
   
   <section>
    <title>Abläufe für Datenobjekte aus dem Server</title>
    <p>
    Wurden Datenobjekte in den Server eingebracht, so steht Benutzern, welche berechtigt sind, die Möglichkeit einer 
    Änderung der Daten und/oder das Löschen der selben frei. Für das Bearbeiten der Daten werden diese zwischenzeitlich 
    auf dem Plattenbereich gespeichert. Bei erfolgreicher Beendigung einer Aktion werden die temporären Daten wieder vom 
    Plattenbereich gelöscht. Im Falle eines Fehlers kann über den Zugriff auf den Plattenbereich (Workflow) und 
    entsprechender Aktionen der Fehler behoben werden. Alle Commits sind als Update ausgelegt, so dass ältere Versionen 
    im Server auch bei einem Commit vom Workflow als Folge eines Fehlers überschrieben werden. Einzelheiten zu den 
    Abläufen finden Sie im <a href="site:appdev_2_1">Programmer Guide</a>. 
    </p>
   </section>
   
   <section>
    <title>Einbindung in das Access Control List - System</title>
    <p>
    In den Bearbeitungsstufen gibt es jeweils einen Button, welcher es gestattet, die ACL's (Access Control Lists – 
    Zugriffslisten) zu ändern. Dies geschieht über zusätzliche Eingabemasken. Alle Änderungen wirken direkt und sofort.
    </p>
   </section>
   
  </section>
  
  <section id="classif_editor">
   <title>Der Klassifikationseditor</title>
   <p>
     In Bibliotheken spielen Klassifikationen eine große Rolle.
     Eine Klassifikation in MyCoRe ist eine hierarchische festgeschriebene Darstellung von Kategorien, welche nach 
     bestimmten Ordnungsprinzipien und Eigenschaften gestaltet ist.
     Die Menge der Klassen/Kategorienamen bilden ein kontrolliertes Vokabular, das es ermöglicht, Dokumente nach den 
     Kriterien der Klassifikation zu ordnen.
     In den Metadaten der Dokumente können beliebige Klassifikationen und Kategorien dem Dokument zugeordnet werden. 
     Typische Klassifikationen wie Dokumentformate, Dokumententyp, Herkunft für die formale Zuordnung von Dokumenten aber 
     auch Sachgruppen der DNB und Pacs für die inhaltliche Klassifizierung werden von MyCoRe im Content-Zweig bereits mitgeliefert. 
   </p>
   <p>
     Mit dem Klassifikationsbrowser bietet MyCoRe die Möglichkeit über Klassifikationen zu navigieren und so zu 
     den zugehörigen Dokumenten zu gelangen.
     Syntax und Beschreibung von Klassifikationen wurden bereits in <a href="05_datamodel.html#Klassifikationen">Kapitel
     6</a> dargestellt. Der nachstehend abgebildete Klassifikationseditor bietet nun die Möglichkeit Klassifikationen
     und Kategorien komfortabel zu bearbeiten.
   </p>
   
   <img src="images/classification_editor_v2.png" alt="Bearbeiten der Klassifikationen" />
    <p class="klein"><strong>Abbildung 6.2:</strong> Der Klassifikationseditor</p> 
       
   <section>
    <title>Start des Klassifikationseditors</title>
    <p>
    Der Editor ist Javascript-basiert und kann in eine beliebige MyCoRe-Webpage mit dem XML-Tag
    <code>&lt;classificationEditor /></code> eingebunden werden. Mitgeliefert wird im Modul classeditor
    die Datei classificationEditor.xml. Der Aufruf in einer lokalen Installation sieht dann wie folgt aus: 
    </p>
    <p>
    Beispiel:<br/>
    <code>http://localhost:8291/modules/classeditor/classificationEditor.xml</code>
    </p>
    <p>
    Erfüllen die Privilegien des Nutzers die Anforderungen, erhält man eine Liste aller im System installierten 
    Klassifikationen, also auch die, die nicht über den Klassifikationsbrowser eingebunden sind.
    </p>
   </section>
   
   <section>
    <title>Operationen des Klassifikationseditors</title>
    
    <note label="Hinweis">
    Klassifikationen werden im Editiermodus grundsätzlich unsortiert angezeigt, da sonst die Verschiebeoperationen für 
    Kategorien nicht sinnvoll nutzbar sind.</note>

   <section>
    <title>Einstellungen</title>
    <p>
    <img src="images/classification_editor_options_v2.png" alt="Einstellungen" style="float:right; padding-left:10px;"/>
    Es ist möglich die Optionen für die Sprachauswahl zu ändern und IDs anzuzeigen.
    <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
    </p>
   </section>

   <section>
    <title>Klassifikationen</title>
    
    <dl>
    <dt style="font-weight:bold;">Neue Klassifikation erstellen</dt>
    <dd>Über den Button [neue Klassifikation erstellen] kann eine Klassifikation angelegt werden. Dazu ist es notwendig 
    mindestens ein Label für die Klassifikation anzugeben. Es können Label und zugehörige Beschreibungen in 
    verschiedenen Sprachen angelegt werden, sowie eine URL.<br/>
    Die ID der Klassifikation wird vom System vergeben.</dd>
    
    <dt style="font-weight:bold;">Klassifikation importieren</dt>
    <dd>Über den Button [Klassifikation importieren] kann eine neue Klassifikation vom Dateisystem in MyCoRe importiert 
    werden, oder eine bereits im System vorhandene Klassifikation aktualisiert werden. Ist der Import der 
    Klassifikation nicht erfolgreich (z.B. XML ist nicht valide, oder die zu aktualisierende Klassifikation existiert 
    nicht im System) erfolgt eine Fehlermeldung und die Klassifikation wird nicht importiert.<br/>Bei Erfolg wird 
    automatisch wieder auf die Liste aller im System vorhandenen Klassifikationen zurückgesprungen.</dd>

    <dt style="font-weight:bold;">Export der Klassifikation</dt>
    <dd>Mit dieser Funktion kann die ausgewählte Klassifikation in einem Extra-Browserfenster im XML-Format angezeigt 
    werden.</dd>
    
    <dt style="font-weight:bold;">Editieren der Klassifikation</dt>
    <dd>Die Beschreibungsdaten der ausgewählten Klassifikation können geändert werden. Es können 
    weitere Label in anderen Sprachen hinzugefügt werden. Die ID kann nicht verändert werden. Ein Label muss für die 
    Klassifikation mindestens belegt sein.</dd>
    
    <dt style="font-weight:bold;">Löschen der Klassifikation</dt>
    <dd>Die ausgewählte Klassifikation wird, inklusive der eventuell vorhandenen Kind-Kategorien gelöscht. Dies
    ist nur möglich, wenn keine der Kategorien aktuell verwendet wird.
    </dd>
    </dl>
   </section>
   
   <section>
   <title>Kategorien</title>
   <p>
   Beim Klick auf das kleine Plus vor der Klassifikationen wird die erste Ebene der Klassifikation mit den zugehörigen 
   Kategorien entfaltet. Für Kategorien gibt es folgende Aktionsmöglichkeiten:
   </p>
   <dl>
   <dt style="font-weight:bold;">Neue Kategorie anlegen</dt>
   <dd><img src="images/category_new_v2.png" alt="Kategorie anlegen" style="float:right; padding-left:10px;" /> 
   Unter der ausgewählten Klassifikation oder Kategorie wird eine neue Kategorie angelegt. Ist eine Kategorie
   ausgewählt, wird die neue Kategorie als Kind dieser angelegt. Nach dem Anlegen kann die neue Kategorie noch
   an die gewünschte Stelle im Baum verschoben werden (siehe dazu "Verschieben der Kategorie").
   <br /><br /><br /><br /><br /><br /></dd>
   
   <dt style="font-weight:bold;">Editieren der Kategorie</dt>
   <dd>Die ausgewählte Kategorie kann jeweils im nebenstehenden Fenster bearbeitet werden. Dabei können Label, Text,
   Beschreibung und URL geändert werden. Die Bearbeitung der ID ist nicht möglich.
   <img src="images/category_edit_v2.png" alt="Kategorie bearbeiten" style="padding:10px 0;" />
   </dd>
   
   <dt style="font-weight:bold;">Löschen der Kategorie</dt>
   <dd><img src="images/category_delete_v2.png" alt="Kategorie löschen" style="float:right; padding-left:10px;"/>
   Besitzt eine Kategorie keine Referenzen, wird also in der Anwendung nirgends benutzt, ist unten links der
   Löschknopf aktiv (rot) und anklickbar. Die ausgewählte Kategorie wird damit inklusive der eventuell vorhandenen
   Kind-Kategorien gelöscht.<br /><br /><br /><br /><br /><br /></dd>
   
   <dt style="font-weight:bold;">Verschieben der Kategorie</dt>
   <dd><img src="images/category_move_v2.png" alt="Kategorie verschieben" style="float:right; padding-left:10px;" />
   Eine Kategorie kann in der Hierarchie im Baum verschoben werden. Durch Anklicken und Halten der linken Maustaste
   kann die Kategorie an die gewünschte Position geschoben werden. Man kann diese dabei auch unterhalb bestehender,
   als Kindkategorien anordnen. Es ist auch möglich eine Kategorie samt ihrer Kinder, also ganze Teilbäume auf diese
   Art zu verschieben.<br />
   So lang der Verschiebevorgang gültig ist, sind Balken und Pfeil grün (siehe nebenstehende Grafik). Bei einer
   ungültigen Bewegung verfärben sich diese rot und die Bewegung findet nicht statt.<br />
   Es ist auch möglich mehrere Kategorien gleichzeitig zu verschieben. Diese müssen dann vorher markiert werden.</dd>
   </dl>
  </section>
  </section>
  
 </section>


</body>
</document>

