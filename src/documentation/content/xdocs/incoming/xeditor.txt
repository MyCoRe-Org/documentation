XEditor-Dokumentation [Draft]
=============================


<xed:source />
==============

Syntax: <xed:source uri="..." />
Beispiel: <xed:source uri="mcrobject:{id} />

Lädt das in diesem Formular zu bearbeitende XML-Dokument von einer URI. 

<xed:source /> ist nur erforderlich, wenn das Formular nicht "leer" starten soll, sondern ein existierendes XML-Dokument zur Bearbeitung laden soll. 
Das können z. B. die Metadaten eines MyCoRe Objektes sein, oder auch eine XML-Datei, die als Template (Vorlage) dient.

Das Attribut @uri kann eine beliebige URI sein, die der MyCoRe URI Resolver unterstützt (z. B. mcrobject:, resource:, webapp:, file:, http:.) und gibt die Quelle an, 
von der das XML-Dokument gelesen wird.

Das Attribut @uri kann optional ein oder mehrere Variablen enthalten, die bei Aufruf des Formulars durch Parameter ersetzt werden. Variablen stehen in geschweiften Klammern und
beginnen mit einem $ Zeichen, z. B.

<xed:source uri="mcrobject:{$id} />

Die Variablen werden bei Aufruf des Formulars durch den konkreten Wert ersetzt, wobei als Quelle die HTTP Request Parameter aus der URL des Aufrufs, Konfigurationswerte aus
mycore.properties oder Werte aus der MCRSession verwendet werden können. 

<xed:source /> ist wiederholbar. Wenn mehrere <xed:source /> Elemente angegeben sind, wird das erste Element verwendet, das keine Variablen enthält, 
oder bei dem alle angegebenen Variablen durch konkrete Werte ersetzt werden können. So kann man z. B. abhängig von Aufruf- oder Konfigurationsparametern 
XML-Dokumente aus verschiedenen Quellen laden.

Beispiel:

<xed:source uri="xslStyle:mcrobject2{$type}:mcrobject:{$id} />
<xed:source uri="mcrobject:{$id} />
<xed:source uri="webapp:template.xml" />

* Wenn das Formular mit [Seite].xed?id=DocPortal_document_07910403 aufgerufen wird, wird die zweite URI verwendet, denn der Parameter $type ist nicht gegeben. 
Die URI mcrobject:DocPortal_document_0791040 lädt die Metadaten des MyCoRe Objektes mit der ID DocPortal_document_07910403 zur Bearbeitung.
* Wenn das Formular stattdessen mit [Seite].xed?type=similar&id=DocPortal_document_07910403 aufgerufen wird, wird die erste URI verwendet, und ein XML Dokument von xslStyle=mcrobject2similar:mcrobject:DocPortal_document_07910403 geladen, d.h. die Metadaten des MyCoRe Objektes mit der ID DocPortal_document_07910403 werden geladen, 
durch das XSL Stylesheet mcrobject2similar.xsl transformiert und in das Formular geladen.
* Wenn das Formular ohne Parameter aufgerufen wird, wird die dritte URI verwendet, und eine statische Vorlage aus der Datei template.xml der Webapplikation geladen.

Es wäre auch denkbar, die komplette URI als Parameter zu übergeben. Davon kann nur abgeraten werden, da es die Aufruf-URLs unnötig lang macht, 
Implementierungsdetails offenlegt und potentiell zu Sicherheitslücken führt:

<xed:source uri="{$uri}" />
Aufruf mit [Seite].xed?uri=mcrobject:DocPortal_document_07910403


<xed:cancel />
==============

Syntax: <xed:cancel url="..." />
Beispiel: <xed:cancel url="receive/{$id}" />

Definiert die URL, zu der bei Abbruch zurückgekehrt werden soll, z. B. bei Betätigen eines Abbrechen-Buttons, um die Bearbeitung aus dem Formular heraus abzubrechen.

<xed:cancel /> sollte angegeben werden, wenn das Formular einen Abbrechen-Button enthält. Die URL wird relative zur Wurzel der Webapplikation angegeben.

Das Attribut @url kann optional ein oder mehrere Variablen enthalten, die bei Aufruf des Formulars durch Parameter ersetzt werden. Variablen stehen in geschweiften Klammern und
beginnen mit einem $ Zeichen, z. B.

<xed:cancel url="receive/{$id}" />

Die Variablen werden bei Aufruf des Formulars durch den konkreten Wert ersetzt, wobei als Quelle die HTTP Request Parameter aus der URL des Aufrufs, Konfigurationswerte aus
mycore.properties oder Werte aus der MCRSession verwendet werden können. 

<xed:cancel /> ist wiederholbar. Wenn mehrere <xed:cancel /> Elemente angegeben sind, wird das erste Element verwendet, das keine Variablen enthält, 
oder bei dem alle angegebenen Variablen durch konkrete Werte ersetzt werden können. So kann man z. B. abhängig von Aufrufparametern bei Abbruch zu verschiedenen 
Zielseiten zurückkehren.

Beispiel:

<xed:cancel url="receive/{$id}" />
<xed:cancel url="index.xml" />

* Wenn das Formular mit [Seite].xed?id=DocPortal_document_07910403 aufgerufen wird, wird bei Abbruch zur Seite receive/DocPortal_document_07910403 zurückgekehrt.
* Wenn das Formular ohne Parameter aufgerufen wird, wird zur Seite index.xml zurückgekehrt.

Es wäre auch denkbar, die komplette URL als Parameter zu übergeben. Davon kann nur abgeraten werden, da es die Aufruf-URLs unnötig lang macht, 
Implementierungsdetails offenlegt und potentiell zu Sicherheitslücken führt:

<xed:cancel url="{$cancelURL}" />
Aufruf mit [Seite].xed?cancelURL=receive/DocPortal_document_07910403


Submit-Buttons definieren
=========================

Syntax: <input type="submit|image" xed:target="..." ... /> oder <button type="submit" xed:target="..." ... />

Submit-Buttons schicken das Formular ab. Das Attribute @xed:target gibt das Ziel an und kann verschiedene Werte annehmen. 
Alle weiteren Eigenschaften der Buttons werden über gewöhnliche HTML Syntax gestaltet. 

Vordefiniert sind die folgenden Ziele:

xed:target="cancel"		Bearbeitung abbrechen
xed:target="debug"		Für das Debugging, zeigt das bearbeitete XML und die Bearbeitungsschritte im Browser an
xed:target="layout"		Für das Debugging, zeigt das bearbeitete XML über den MyCoRe LayoutService an (d.h. durch einen Transformer, der üblicherweise via XSL Stylesheet zu HTML rendert)
xed:target="servlet"	Sendet das resultierende XML-Dokument an ein Servlet


Abbrechen-Buttons definieren
============================

Syntax: <input type="submit|image" xed:target="cancel" ... /> oder <button type="submit" xed:target="cancel" ... />

Abbrechen-Buttons können auf verschiedene Weise gestaltet werden. 
Das Attribut @xed:target="cancel" weist die Buttons als Abbrechen-Buttons aus. 
Alle weiteren Eigenschaften der Buttons werden über gewöhnliche HTML Syntax gestaltet. 
Die URL, zu der bei Betätigen des Buttons zurückgekehrt wird; wird über das Element <xed:cancel /> definiert.

Beispiel:

<input type="submit" class="roundedButton" xed:target="cancel" value="{i18n:button.cancel}" />

In diesem Beispiel wird die sprachabhängige Beschriftung des Buttons mit value="{i18n:button.cancel}" aus dem Schlüssel button.cancel aus den messages-*.properties Dateien gelesen.


Debug-Buttons definieren
========================

Syntax: <input type="submit|image" xed:target="debug" ... /> oder <button type="submit" xed:target="debug" ... />

Ein Debug-Button ist während der Implementierung eines Formulars nützlich, um anzuzeigen, welches XML-Dokument aus der Bearbeitung im Formular resultiert, ohne dieses an das Zielservlet zu senden.
Das Attribut @xed:target="debug" weist die Buttons als Abbrechen-Buttons aus. 
Alle weiteren Eigenschaften der Buttons werden über gewöhnliche HTML Syntax gestaltet. 

Beispiel:

<input type="submit" class="roundedButton" xed:target="debug" value="Debug" />


Submit-Buttons zum Absenden an ein Servlet
==========================================

Syntax: <input type="submit|image" xed:target="servlet" xed:href="..." ... /> oder <button type="submit" xed:target="servlet" xed:href="..." ... />

Das Attribut @xed:target="servlet" definiert, dass beim Absenden des Formulars das resultierende XML via Request Dispatching an ein Ziel-Servlet gesendet werden soll.
Das Attribut @xed:href gibt die URL oder den Namen dieses Servlets an, so wie er in der web.xml der Anwendung definiert ist.
Alle weiteren Eigenschaften der Buttons werden über gewöhnliche HTML Syntax gestaltet. 

Beispiel:

<input type="submit" class="roundedButton" xed:target="servlet" xed:href="MCRSearchServlet" value="{i18n:button.search}" />

In diesem Beispiel wird die sprachabhängige Beschriftung des Buttons mit value="{i18n:button.search}" aus dem Schlüssel button.search aus den messages-*.properties Dateien gelesen.
Der Button schickt das resultierende XML-Dokument, hier angenommen die XML-Darstellung einer Suchanfrage, an das MCRSearchServlet, um eine Suche auszuführen.

Das Ziel-Servlet erhält das resultierende XML-Dokument als JDOM Document in einem Request Attribut mit dem Schlüssel MCRXEditorSubmission übergeben:

HttpServletRequst request;
org.jdom.Document xml = (org.jdom.Document) (request.getAttribute("MCRXEditorSubmission"));

Sofern Validierungsregeln angegeben sind, wird das Zielservlet nur aufgerufen, wenn die Validierung erfolgreich ist. Wenn sie nicht erfolgreich ist, wird zum Formular zurückgekehrt und auf die fehlerhafte Eingabe hingewiesen.


Cleanup-Rules
=============

Syntax: <xed:cleanup-rule xpath="..." relevant-if="..." />

Cleanup-Rules sind Bereinigunsregeln, die logisch leere XML-Elemente oder -Attribute vor Übergabe an das Zielservlet aus dem resultierenden XML herauslöschen.
Das Attribut @xpath gibt in Form eines XPath-Ausdruckes an, auf welche Elemente oder Attribute sich die Regel bezieht. 
Das Attribut @relevant-if gibt in Form eines XPath-Tests an, unter welchen Bedingungen diese XML-Knoten als relevant erachtet werden.

Sofern keine weiteren Cleanup-Rules definiert sind, gelten die folgenden Standard-Regeln:

<xed:cleanup-rule xpath="//@*" relevant-if="string-length(.) > 0" />
<xed:cleanup-rule xpath="//*" relevant-if="@* or * or (string-length(text()) > 0)" />

Die Standard-Regeln entfernen leere Attribute und Elemente aus dem resultierenden XML-Dokument. Ein Element ist leer, wenn es keine Kindelemente, keine Attribute und keinen Text enthält.
Diese Regeln lassen sich durch eigene Regeln ergänzen oder überschreiben.

Beispiel (Suchmaske):

<xed:cleanup-rule xpath="//condition" relevant-if="string-length(@value) &gt; 0" />

entfernt alle <condition /> Elemente, deren @value Attribut leer ist. In einer MyCoRe Suchmaske werden die Suchfelder als <condition /> Elemente dargestellt, mit den Attributen @field für das zu durchsuchende Feld, @operator für den zu verwendenden Suchoperator, und @value für den eingegebenen und zu suchenden Wert, z. B. 

<condition field="title" operator="contains" value="Optik" />

Die Attribute @field und @operator werden in der Suchmaske durch hidden-Felder oder Auswahllisten festgelegt. Wenn aber kein zu suchender Wert eingegeben wird, ist die gesamte Suchbedingung nicht
relevant, und sie wird durch die Bereinigungsregel entfernt.

Beispiel (MODS):
<xed:cleanup-rule xpath="//mods:*" relevant-if="(string-length(text()) &gt; 0) or mods:* or (string-length(@xlink:href) &gt; 0)" />
<xed:cleanup-rule xpath="//mods:name" relevant-if="mods:namePart" />

Im MODS Datenmodell werden Personennamen z. B. wie folgt dargestellt:

<mods:name type="personal">
  <mods:namePart type="given">John</namePart>
  <mods:namePart type="family">Huston</namePart>
  <mods:role>
    <mods:roleTerm type="code" authority="marcrelator">aut</roleTerm>
  </mods:role>
</mods:name>

Angenommen, ein Eingabeformular besitzt für an einer Publikation beteiligte Personen Eingabefelder für Vor- und Nachname (mods:namePart), sowohl eine Auswahlliste für die Rolle (Autor, Herausgeber etc. entsprechend mods:roleTerm). Dann entfernt die zweite Bereinigungsregel das mods:name Element, wenn keine mods:namePart Elemente vorhanden sind, d.h. keine Namensteile eingegeben wurden. Die erste Bereinigungsregel entfernt alle mods Elemente, die keine anderen mods Elemente enthalten, oder kein xlink:href Attribut. Somit wird das mods:namePart Element entfernt, wenn kein Text enthalten ist. Das Attribut @type ist nicht relevant, da die Standard-Regel für mods Elemente überschrieben wurde.

Bereinigungsregeln werden rekursiv und iterativ auf das resultierende XML-Dokumente angewandt, bis sich das Dokument nicht mehr ändert, d.h. aufgrund der Regeln keine weiteren Knoten als zu entfernen identifiziert werden.


<xed:post-processor />
======================

Syntax: <xed:post-processor xsl="..." />

Gibt mit dem Attribut @xsl ein Stylesheet an, das zur Nachbearbeitung des resultierenden XML-Dokumentes verwendet werden soll. Über ein solches XSL-Stylesheet kann das XML-Dokument nach Bearbeitung im Formular, aber noch vor Übergabe an das Zielservlet transformiert werden. 

Über die XEditor-Syntax können Eingabefelder flexibel auf XML-Elemente und Attribute abgebildet werden. In einigen Fällen kann die XML-Struktur aber zu komplex sein, um sie einfach auf Eingabefelder abzubilden. In solchen Fällen kann man das zu bearbeitende XML-Dokument

* vor der Bearbeitung im Formular durch ein XSL-Stylesheet in eine für die Bearbeitung geeignetere Form umwandeln: Dies ist einfach über Verwendung des xslStyle URI Resolvers möglich, z. B.
<xed:source uri="xslStyle:mods-preprocessor:mcrobject:{$id}" />
* nach der Bearbeitung im Formular wieder durch ein XSL-Stylesheet in die gewünschte XML-Struktur zurück transformieren, z. B.
<xed:post-processor xsl="mods-postprocessor.xsl" />

Beispiel:
Im MODS Datenmodell wird eine Publikation, die auf einer einzelnen Seite veröffentlicht wird, dargestellt als

<mods:detail type="page">
  <mods:number> Seitenzahl </mods:number>
</mods:detail>

Wenn sich die Publikation über mehrere Seiten erstreckt, wird ein von-bis Bereich angegeben:

<mods:extent unit="pages">
  <mods:start> Seite von </mods:start>
  <mods:end> Seite bis </mods:end>
</mods:extent>

Angenommen, das Eingabeformular soll grundsätzlich nur die Eingabefelder "Seite von" und "Seite bis" anbieten, dann könnte man den Sonderfall einer einzelnen Seite abbilden, indem

* in einem Stylesheet mods-preprocessor.xsl alle mods:detail[@type='page']/mods:number zu mods:extent mit identischen mods:start und mods:end Werten transformiert werden
* in einem Stylesheet mods-postprocessor.xsl alle mods:extent mit identischen oder einzelnen mods:start und mods:end Werten zu einem einzelnen mods:detail[@type='page']/mods:number transformiert werden


<xed:output />
==============

Syntax: <xed:output value="..." i18n="..." />

Ermöglicht die Ausgabe eines Wertes. Der Wert kann über einen XPath-Ausdruck definiert werden und/oder das aktuelle Binding im bearbeitetn XML Dokument verwenden. Auch eine Kombination mit mehrsprachigen Bezeichnern aus messages-*.properties Dateien ist möglich. 

Wenn kein Attribut angegeben ist, wird der erste durch das aktuelle Binding ausgewählte Wert ausgegeben. Beispiel:

<xed:bind xpath="title">
  <label>Titel:</label>
  <xed:output />
</xed:bind>

Wenn das Attribut @value angegeben ist, wird der darin enthaltene XPath-Ausdruck ausgewertet und ausgegeben. Der XPath-Ausdruck kann die XML-Struktur des bearbeiteten Dokumentes, sowie Variablen verwenden, die aus HTTP Request Parametern, Konfigurationsparametern aus mycore.properties oder MCRSession Variablen stammen. Beispiele:

<label>Name: </label>
<xed:output value="concat(mods:namePart[@type='family'],', ',mods:namePart[@type='given'])" />

<xed:bind xpath="title">
  Diese Publikation mit dem Titel "<xed:output />" dürfen Sie als <xed:output value="$SomeUser" /> bearbeiten.
</xed:bind>

Wenn das Attribut @i18n angegeben ist, wird der mehrsprachige Bezeichner aus den messages-*.properties Dateien ausgegeben, dessen Schlüssel angegeben ist. Beispiel:

<label>
  <xed:output i18n="edit.title" />:
</label>

Wenn sowohl das Attribut @value als auch das Attribut @i18n angegeben ist, wird zunächst der XPath-Ausdruck aus dem Attribut @value ausgewertet, und der resultierende Wert in den mehrsprachigen Bezeichner eingesetzt. Der Bezeichner in den messages-*.properties Dateien muss einen entsprechenden Platzhalter vorsehen. Beispiel:

In messages-de.properties: 
edit.datePublished=Das Dokument wurde am {0} veröffentlicht.

In messages-en.properties: 
edit.datePublished=The document was publised at {0}.

<label>
  <xed:output value="date[@type='published']" i18n="edit.datePublished" />
</label>


Ausgabe eines Wertes innerhalb von HTML-Attributen
==================================================

Syntax: {XPath} oder {i18:key} oder {i18n:key,XPath}

Enthält ein Attribut einen Ausdruck, der durch geschweifte Klammern umschlossen ist, wird dieser Ausdruck ausgewertet und an dieser Stelle im Attribut eingesetzt. Bei dem Ausdruck kann es sich um einen XPath-Ausdruck handeln, oder um einer mehrsprachigen Bezeichner aus den messages-*.properties Dateien. Der XPath-Ausdruck kann die XML-Struktur des bearbeiteten Dokumentes, sowie Variablen verwenden, die aus HTTP Request Parametern, Konfigurationsparametern aus mycore.properties oder MCRSession Variablen stammen. 

Beispiele:

<img src="{@href}" />
<a href="{$WebApplicationBaseURL}receive/{@xlink:href}">Link zum reverenzierten Objekt</a>

Wenn der Ausdruck mit "i18n:" beginnt, wird der mehrsprachige Bezeichner aus den messages-*.properties Dateien ausgegeben, dessen Schlüssel angegeben ist. Es ist möglich, einen XPath-Ausdruck mit einem i18n Schlüssel zu kombinieren, indem Schlüssen und XPath Ausdruck durch ein Komma getrennt werden. In diesem Fall wird zunächst der XPath-Ausdruck ausgewertet, und der resultierende Wert in den mehrsprachigen Bezeichner eingesetzt. Der Bezeichner in den messages-*.properties Dateien muss einen entsprechenden Platzhalter vorsehen.

Beispiele:

<input type="submit" xed:target="cancel" value="{i18n:label.cancel}" />
<input type="text" placeholder="{i18n:placeholder.date.issued}" />
<img alt="{i18n:image.title,title[@type='main']} src="{@href}" />


<xed:if />
==========

Syntax: <xed:if test="...">...</xed:if>

Ermöglicht es, einen Teil des Formulars nur unter einer bestimmten Bedingung auszuführen, die durch einen XPath-Test bestimmt wird. Der XPath-Test kann die XML-Struktur des bearbeiteten Dokumentes, sowie Variablen verwenden, die aus HTTP Request Parametern, Konfigurationsparametern aus mycore.properties oder MCRSession Variablen stammen. Nur wenn die Testbedingung erfüllt ist, wird der durch <xed:if /> umschlossene Formularabschnitt verarbeitet und angezeigt.

Beispiele:

<xed:if test="string-length(@valueURI) &gt; 0">
  <a href="{@valueURI}">
	<xed:output value="concat(mods:namePart[@type='family'],', ',mods:namePart[@type='given'])" />
  </a>
</xed:if>

<xed:if test="$mode='advanced'">
  <h3>Erweiterter Modus mit zusätzlichen Eingabefeldern:</h3>
  ...
</xed:if>


<xed:choose />
==============

Syntax: 

<xed:choose>
  <xed:when test="...">...</xed:when>
  <xed:when test="...">...</xed:when>
  <xed:otherwise>...</xed:otherwise>
</xed:choose>

Ermöglicht es, abhängig von ein oder mehreren Bedingungen unterschiedliche Teile oder Varianten eines Formulars auszuführen. 

Jedes <xed:when /> Element definiert einen XPath-Test. Der XPath-Test kann die XML-Struktur des bearbeiteten Dokumentes, sowie Variablen verwenden, die aus HTTP Request Parametern, Konfigurationsparametern aus mycore.properties oder MCRSession Variablen stammen. Nur wenn die Testbedingung erfüllt ist, wird der durch <xed:when /> umschlossene Formularabschnitt verarbeitet und angezeigt. Wenn mehrere <xed:when /> Elemente angegeben sind, wird nur das erste Element berücksichtigt, dessen Testbedingung erfüllt ist. 

Das Element <xed:otherwise /> ist optional. Es wird nur dann ausgeführt, wenn keine der Testbedingungen der vorangehenden <xed:when /> Elemente erfüllt ist. In diesem Fall wird der duch <xed:otherwise /> umschlossene Formularabschnitt verarbeitet und angezeigt.

Beispiel:

<xed:choose>
  <xed:when test="@status='new'">
	<label>Veröffentlichen am:</label>
	<xed:bind xpath="dateToPublish">
	  <input type="text />
	</xed:bind>
  </xed:when>
  <xed::otherwise> <!-- status='published' -->
	<label>Veröffentlichungsdatum: </label>
	<xed:output value="dateToPublished" />
  </xed:otherwise>
</xed:choose>


<xed:multi-lang />
==================

Ermöglicht es, abhängig von der aktuell verwendeten Sprache (Variable $CurrentLang der MCRSession), Teile des Formulars in verschiedenen Varianten anzubieten.

Syntax:

<xed:multi-lang>
  <xed:lang xml:lang="..."></xed:lang>
  <xed:lang xml:lang="..."></xed:lang>
</xed:multi-lang>

Das Attribut @xml:lang definiert die Sprache (nach IETF BCP 47), für die der umschlossene Block verarbeitet und angezeigt werden soll. Wenn kein <xed:lang /> Bereich für die aktuelle Sprache definiert ist, wird der Bereich verwendet, der für die Default-Sprache (MCR.Metadata.DefaultLang aus mycore.properties) definiert ist. Wenn auch für die Default-Sprache kein Bereich definiert ist, wird der erste <xed:lang /> Bereich verwendet.

Beispiel:

<xed:multi-lang>
  <xed:lang xml:lang="de">
     <label>Straße:</label>...
	 <label>Hausnummer:</label>...
     <label>PLZ:</label>...
	 <label>Ort:</label>...
  </xed:lang>
  <xed:lang xml:lang="en">
	 <label>Number:</label>...
     <label>Street:</label>...
	 <label>City:</label>...
	 <label>ZIP Code:</label>...
  </xed:lang>
</xed:multi-lang>

